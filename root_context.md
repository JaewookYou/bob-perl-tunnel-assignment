# CMDI-Tunnel Challenge Context

이 문서는 Command Injection을 통한 Perl 터널링 실습 환경의 모든 분석 내용, 가설, 전략에 대한 단일 진실 공급원(Single Source of Truth)입니다.

## 1. 챌린지 목표

파일 업로드 기능에 존재하는 Command Injection 취약점을 이용하여, 제한된 환경에서 Perl 스크립트로 터널링을 구축해야 합니다. 최종 목표는 외부에서 직접 접근할 수 없는 **내부 네트워크의 다른 웹 서비스(`internal_web`)에 접속**하여 "Congratulation!" 메시지를 확인하는 것입니다.

## 2. 제약 조건

1.  **취약점 위치**: 파일 업로드 시 사용되는 `multipart/form-data`의 `filename` 파라미터에 **Blind Command Injection** 취약점이 존재합니다. 서버는 `echo '[filename]' > /dev/null` 형태의 명령을 실행하므로, 작은따옴표(`'`)를 탈출해야 합니다.
2.  **명령어 실행 결과 확인**: 명령어 실행 결과는 직접 반환되지 않습니다. 공격자는 명령어의 출력값을 `/uploads/` 디렉토리에 파일로 저장한 뒤, 별도로 존재하는 **파일 다운로드 취약점**을 통해 해당 파일의 내용을 확인해야 합니다.
3.  **웹셸 차단**: 업로드된 `.jsp` 파일은 서버에서 실행되지 않습니다.
4.  **문자열 제한 (클라이언트 측)**: `filename`에는 경로 구분 문자인 `/`, `\`를 사용할 수 없습니다.
5.  **문자열 제한 (서버 측)**: 서버는 `filename` 값에서 `/`, `\` 문자를 필터링합니다.
6.  **길이 제한**: `filename`의 길이는 50바이트 미만으로 제한됩니다.
7.  **최소한의 명령어**: 서버에는 `perl`을 제외한 `base64`, `wget`, `curl`, `nc`, `python` 등 일반적인 유틸리티가 존재하지 않습니다.
8.  **네트워크 차단 (Out-of-Band 불가)**: 컨테이너 방화벽(`iptables`)으로 인해 외부 인터넷으로의 연결이 차단되어 있습니다. 단, 내부 Docker 네트워크 간의 통신은 허용됩니다. 리버스 셸 공격이 불가능합니다.
9.  **권한 제한**: 웹 서버는 `root`가 아닌 일반 사용자(`tomcat_user`) 권한으로 실행됩니다.

## 3. 시스템 아키텍처

*   **웹 서버**: Apache Tomcat 9 (`web` 서비스)
*   **내부 검증용 서버**: Flask (`internal_web` 서비스)
*   **서버 사이드 언어**: JSP (JavaServer Pages)
*   **기반 OS**: Alpine Linux (Docker)
*   **핵심 유틸리티**: `perl`

## 4. 의도된 해결 전략 가이드

1.  **취약점 확인**: `filename` 파라미터에 `';sleep 5;echo '`와 같은 페이로드를 삽입하여 시간 기반 Blind Command Injection이 동작하는지 확인합니다. 작은따옴표를 닫고, 세미콜론으로 명령어를 구분한 뒤, 다시 echo 명령어의 따옴표를 열어주는 구문이 필요합니다.
2.  **제한사항 분석**: 길이 및 문자열 제한, 명령어 부재, 네트워크 차단 등의 제약 조건을 명확히 인지합니다.
3.  **공격 벡터 구상**:
    *   명령어 실행 결과를 확인하기 위해, `ls -al > /usr/local/tomcat/webapps/ROOT/uploads/output.txt` 와 같이 명령어 실행 결과를 `uploads` 디렉토리 내 파일로 리다이렉션해야 합니다.
    *   `download.jsp?file=output.txt` 와 같이 파일 다운로드 취약점을 이용하여 결과 파일의 내용을 확인합니다.
    *   네트워크가 차단되어 있으므로, 리버스 셸 대신 **바인드 셸(Bind Shell)** 또는 **포트 포워딩(Port Forwarding)**과 같은 터널링 기법을 사용해야 합니다.
    *   `perl` 스크립트를 `web` 컨테이너에 업로드하고 실행하여, `web` 컨테이너의 특정 포트로 들어오는 요청을 `internal_web:5000`으로 전달하는 터널을 구축합니다.
4.  **페이로드 작성 및 실행**: 최종적으로 `filename`에 터널링 스크립트를 실행하는 페이로드를 삽입합니다.
5.  **내부 서비스 접근**: 구축된 터널을 통해 `http://localhost:8080/[터널포트]` 와 같은 형태로 `internal_web`에 접근하여 "Congratulation!" 메시지를 확인합니다.
